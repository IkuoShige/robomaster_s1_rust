/// RoboMaster S1 command table containing predefined command templates
/// This is a direct port of the Python command_table.py with type safety improvements

pub mod builder;

use std::collections::HashMap;

// Re-export builder types for convenience
pub use builder::{CommandBuilder, MovementParams, GimbalParams, LedColor};

/// Command template type - each command is a vector of bytes with special values:
/// - 0xFF: Placeholder for CRC8/CRC16 or counter values
/// - Other values: Fixed protocol bytes
pub type CommandTemplate = Vec<u8>;

/// Special placeholder values in command templates
pub mod placeholders {
    /// Placeholder for CRC8 checksum
    pub const CRC8_PLACEHOLDER: u8 = 0xFF;
    /// Placeholder for CRC16 checksum (appears in pairs)
    pub const CRC16_PLACEHOLDER: u8 = 0xFF;
    /// Placeholder for command counter values
    pub const COUNTER_PLACEHOLDER: u8 = 0xFF;
}

/// Command indices for easier access to specific commands
pub mod commands {
    pub const BOOT_0: usize = 0;
    pub const BOOT_1: usize = 1;
    pub const BOOT_2: usize = 2;
    pub const BOOT_3: usize = 3;
    pub const GIMBAL: usize = 4;
    pub const TWIST: usize = 5;
    pub const LED_PATTERN_6: usize = 6;
    pub const LED_PATTERN_7: usize = 7;
    pub const LED_PATTERN_8: usize = 8;
    pub const LED_COLOR: usize = 9;
    pub const LED_BRIGHT_10: usize = 10;
    pub const LED_ON: usize = 11;
    pub const LED_BRIGHT_12: usize = 12;
    pub const LED_BRIGHT_13: usize = 13;
    pub const LED_BRIGHT_14: usize = 14;
    pub const LED_BRIGHT_15: usize = 15;
    pub const LED_BRIGHT_16: usize = 16;
    pub const LED_BRIGHT_17: usize = 17;
    pub const LED_BRIGHT_18: usize = 18;
    pub const LED_BRIGHT_19: usize = 19;
    pub const TOUCH_20: usize = 20;
    pub const TOUCH_21: usize = 21;
    pub const BOOT_4: usize = 22;
    pub const BOOT_5: usize = 23;
    pub const BOOT_6: usize = 24;
    pub const BOOT_7: usize = 25;
    pub const BOOT_8: usize = 26;
    pub const BOOT_9: usize = 27;
    pub const BOOT_10: usize = 28;
    pub const BOOT_11: usize = 29;
    pub const BOOT_12: usize = 30;
    pub const BOOT_13: usize = 31;
    pub const BOOT_14: usize = 32;
    pub const BOOT_15: usize = 33;
    pub const BOOT_16: usize = 34;
    pub const DEBUG_35: usize = 35;
    pub const DEBUG_36: usize = 36;
}

/// Boot command sequence (commands 26-34 in Python)
pub const BOOT_COMMAND_START: usize = 26;
pub const BOOT_COMMAND_END: usize = 34;

/// Get the complete command table
pub fn get_command_table() -> Vec<CommandTemplate> {
    vec![
        vec![0x55,0x0D,0x04,0xFF,0x0A,0xFF,0xFF,0xFF,0x40,0x00,0x01,0xFF,0xFF],
        vec![0x55,0x0E,0x04,0xFF,0x09,0x03,0xFF,0xFF,0xA0,0x48,0x08,0x01,0xFF,0xFF],
        vec![0x55,0x0F,0x04,0xFF,0xF1,0xC3,0xFF,0xFF,0x00,0x0A,0x53,0x32,0x00,0xFF,0xFF],
        vec![0x55,0x12,0x04,0xFF,0xF1,0xC3,0xFF,0xFF,0x40,0x00,0x58,0x03,0x92,0x06,0x02,0x00,0xFF,0xFF],
        vec![0x55,0x14,0x04,0xFF,0x09,0x04,0xFF,0xFF,0x00,0x04,0x69,0x08,0x05,0x00,0x00,0x00,0x00,0x6D,0xFF,0xFF],
        vec![0x55,0x1B,0x04,0xFF,0x09,0xC3,0xFF,0xFF,0x00,0x3F,0x60,0x00,0x04,0x20,0x00,0x01,0x08,0x40,0x00,0x02,0x10,0x04,0x03,0x00,0x04,0xA3,0x88],
        vec![0x55,0x49,0x04,0xFF,0x49,0x03,0xFF,0xFF,0x00,0x3F,0x70,0xB4,0x11,0x34,0x03,0x00,0x00,0xF7,0x05,0x42,0x08,0x10,0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x0E,0xF3,0x0B,0xD9,0x07,0x0E,0x07,0x3D,0x07,0x6A,0x08,0x62,0x0A,0x05,0x0B,0xD6,0x0B,0xFF,0xFF],
        vec![0x55,0x0E,0x04,0xFF,0x09,0x17,0xFF,0xFF,0x00,0x3F,0x51,0x11,0xFF,0xFF],
        vec![0x55,0x16,0x04,0xFF,0x09,0x17,0xFF,0xFF,0x00,0x3F,0x55,0x73,0x00,0xFF,0x00,0x01,0x28,0x00,0x00,0x00,0xFF,0xFF],
        vec![0x55,0x1A,0x04,0xFF,0x09,0x18,0xFF,0xFF,0x00,0x3F,0x32,0x05,0xFF,0x00,0x00,0x7F,0x46,0x00,0x64,0x00,0x64,0x00,0x30,0x00,0xFF,0xFF],
        vec![0x55,0x1A,0x04,0xFF,0x09,0x18,0xFF,0xFF,0x00,0x3F,0x32,0x01,0xFF,0x00,0x00,0x7F,0x46,0x00,0xC8,0x00,0xC8,0x00,0x0F,0x00,0xFF,0xFF],
        vec![0x55,0x1A,0x04,0xFF,0x09,0x18,0xFF,0xFF,0x00,0x3F,0x32,0x01,0xFF,0x00,0x00,0x7F,0x46,0x00,0x00,0x00,0x00,0x00,0x3F,0x00,0xFF,0xFF],
        vec![0x55,0x1A,0x04,0xFF,0x09,0x18,0xFF,0xFF,0x00,0x3F,0x32,0x02,0xFF,0x00,0xFF,0xFF,0xFF,0x00,0xF4,0x01,0xF4,0x01,0x3F,0x00,0xFF,0xFF],
        vec![0x55,0x1A,0x04,0xFF,0x09,0x18,0xFF,0xFF,0x00,0x3F,0x32,0x73,0xFF,0x00,0xFF,0x00,0x00,0x01,0x64,0x00,0x0A,0x00,0x3F,0x00,0xFF,0xFF],
        vec![0x55,0x1A,0x04,0xFF,0x09,0x18,0xFF,0xFF,0x00,0x3F,0x32,0x05,0xF0,0x00,0xC8,0x00,0x00,0x00,0x64,0x00,0x64,0x00,0x30,0x00,0xFF,0xFF],
        vec![0x55,0x1A,0x04,0xFF,0x09,0x18,0xFF,0xFF,0x00,0x3F,0x32,0x01,0xFF,0x00,0xC8,0x00,0x00,0x00,0xC8,0x00,0xC8,0x00,0x0F,0x00,0xFF,0xFF],
        vec![0x55,0x1A,0x04,0xFF,0x09,0x18,0xFF,0xFF,0x00,0x3F,0x32,0x05,0xF0,0x00,0x00,0x00,0xFF,0x00,0x64,0x00,0x64,0x00,0x30,0x00,0xFF,0xFF],
        vec![0x55,0x1A,0x04,0xFF,0x09,0x18,0xFF,0xFF,0x00,0x3F,0x32,0x01,0xFF,0x00,0x00,0x00,0xFF,0x00,0xC8,0x00,0xC8,0x00,0x0F,0x00,0xFF,0xFF],
        vec![0x55,0x1A,0x04,0xFF,0x09,0x18,0xFF,0xFF,0x00,0x3F,0x32,0x05,0xF0,0x00,0x00,0xFF,0x00,0x00,0x64,0x00,0x64,0x00,0x30,0x00,0xFF,0xFF],
        vec![0x55,0x1A,0x04,0xFF,0x09,0x18,0xFF,0xFF,0x00,0x3F,0x32,0x01,0xFF,0x00,0x00,0xFF,0x00,0x00,0xC8,0x00,0xC8,0x00,0x0F,0x00,0xFF,0xFF],
        vec![0x55,0x0F,0x04,0xFF,0x09,0x04,0xFF,0xFF,0x40,0x04,0x4C,0x00,0x00,0xFF,0xFF],
        vec![0x55,0x0F,0x04,0xFF,0x09,0x04,0xFF,0xFF,0x40,0x04,0x4C,0x02,0x00,0xFF,0xFF],
        vec![0x55,0x0E,0x04,0xFF,0x09,0xC3,0xFF,0xFF,0x40,0x3F,0x3F,0x01,0xFF,0xFF],
        vec![0x55,0x0E,0x04,0xFF,0x09,0xC3,0xFF,0xFF,0x40,0x3F,0x3F,0x02,0xFF,0xFF],
        vec![0x55,0x0E,0x04,0xFF,0x09,0xC3,0xFF,0xFF,0x40,0x3F,0x3F,0x03,0xFF,0xFF],
        vec![0x55,0x0E,0x04,0xFF,0x09,0xC3,0xFF,0xFF,0x40,0x3F,0x3F,0x04,0xFF,0xFF],
        vec![0x55,0x1B,0x04,0xFF,0x09,0xC3,0x00,0x00,0x00,0x3F,0x60,0x00,0x04,0x20,0x00,0x01,0x00,0x40,0x00,0x02,0x10,0x00,0x03,0x00,0x00,0xFF,0xFF],
        vec![0x55,0x14,0x04,0xFF,0x09,0x04,0x00,0x00,0x00,0x04,0x69,0x08,0x05,0x00,0x00,0x00,0x00,0x01,0xFF,0xFF],
        vec![0x55,0x0F,0x04,0xFF,0x09,0x04,0x02,0x00,0x40,0x04,0x4C,0x02,0x00,0xFF,0xFF],
        vec![0x55,0x0E,0x04,0xFF,0x09,0x03,0x00,0x00,0x00,0x3F,0x3F,0x02,0xFF,0xFF],
        vec![0x55,0x15,0x04,0xFF,0xF1,0xC3,0x00,0x00,0x00,0x03,0xD7,0x01,0x07,0x00,0x02,0x00,0x00,0x00,0x00,0xFF,0xFF],
        vec![0x55,0x12,0x04,0xFF,0x09,0x03,0x01,0x00,0x40,0x48,0x01,0x09,0x00,0x00,0x00,0x03,0xFF,0xFF],
        vec![0x55,0x1C,0x04,0xFF,0x09,0x03,0x02,0x00,0x40,0x48,0x03,0x09,0x00,0x03,0x00,0x01,0xFB,0xDC,0xF5,0xD7,0x03,0x00,0x02,0x00,0x01,0x00,0xFF,0xFF],
        vec![0x55,0x12,0x04,0xFF,0x09,0x03,0x03,0x00,0x40,0x48,0x01,0x09,0x00,0x00,0x00,0x03,0xFF,0xFF],
        vec![0x55,0x24,0x04,0xFF,0x09,0x03,0x04,0x00,0x40,0x48,0x03,0x09,0x01,0x03,0x00,0x02,0xA7,0x02,0x29,0x88,0x03,0x00,0x02,0x00,0x66,0x3E,0x3E,0x4C,0x03,0x00,0x02,0x00,0x32,0x00,0xFF,0xFF],
        vec![0x55,0x3C,0x04,0xFF,0x09,0x03,0x05,0x00,0x40,0x48,0x03,0x09,0x02,0x03,0x00,0x05,0x09,0xA3,0x26,0xE2,0x03,0x00,0x02,0x00,0xB3,0xF7,0xE6,0x47,0x03,0x00,0x02,0x00,0xF4,0x1D,0x1C,0xDC,0x03,0x00,0x02,0x00,0x03,0xC5,0x58,0x08,0x03,0x00,0x02,0x00,0x42,0xEE,0x13,0x1D,0x03,0x00,0x02,0x00,0x05,0x00,0xFF,0xFF],
        vec![0x55,0x0F,0x04,0xFF,0x09,0x04,0xFF,0xFF,0x00,0x04,0x0D,0xB5,0x2A,0xFF,0xFF],
        vec![0x55,0x0F,0x04,0xFF,0x09,0x04,0xFF,0xFF,0x00,0x04,0x0D,0xF2,0x7E,0xFF,0xFF],
    ]
}

/// Create a lookup map for commands by name
pub fn create_command_map() -> HashMap<&'static str, usize> {
    let mut map = HashMap::new();
    
    // Boot commands
    for i in BOOT_COMMAND_START..=BOOT_COMMAND_END {
        map.insert(
            match i {
                26 => "boot_26",
                27 => "boot_27", 
                28 => "boot_28",
                29 => "boot_29",
                30 => "boot_30",
                31 => "boot_31",
                32 => "boot_32",
                33 => "boot_33",
                34 => "boot_34",
                _ => "boot_unknown",
            },
            i,
        );
    }
    
    // Main commands
    map.insert("gimbal", commands::GIMBAL);
    map.insert("twist", commands::TWIST);
    map.insert("led_color", commands::LED_COLOR);
    map.insert("led_on", commands::LED_ON);
    map.insert("touch_20", commands::TOUCH_20);
    map.insert("touch_21", commands::TOUCH_21);
    
    map
}

/// Get command length (second byte in command template)
pub fn get_command_length(command_template: &CommandTemplate) -> Option<usize> {
    if command_template.len() >= 2 {
        Some(command_template[1] as usize)
    } else {
        None
    }
}

/// Check if a byte position should be replaced with CRC8
pub fn is_crc8_position(command_template: &CommandTemplate, position: usize) -> bool {
    position == 3 && 
    position < command_template.len() && 
    command_template[position] == placeholders::CRC8_PLACEHOLDER
}

/// Check if byte positions should be replaced with command counter
pub fn is_counter_position(command_template: &CommandTemplate, position: usize) -> bool {
    (position == 6 || position == 7) &&
    position < command_template.len() &&
    command_template[position] == placeholders::COUNTER_PLACEHOLDER
}

/// Find CRC16 placeholder positions (last two 0xFF bytes)
pub fn find_crc16_positions(command_template: &CommandTemplate) -> Option<(usize, usize)> {
    let len = command_template.len();
    if len >= 2 && 
       command_template[len - 2] == placeholders::CRC16_PLACEHOLDER &&
       command_template[len - 1] == placeholders::CRC16_PLACEHOLDER {
        Some((len - 2, len - 1))
    } else {
        None
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_command_table_not_empty() {
        let table = get_command_table();
        assert!(!table.is_empty());
        assert_eq!(table.len(), 38); // Should have 38 commands
    }

    #[test]
    fn test_command_length_extraction() {
        let table = get_command_table();
        
        // Test first command
        let length = get_command_length(&table[0]);
        assert_eq!(length, Some(0x0D));
        
        // Test LED command
        let led_length = get_command_length(&table[commands::LED_COLOR]);
        assert_eq!(led_length, Some(0x1A));
    }

    #[test]
    fn test_crc8_position_detection() {
        let table = get_command_table();
        let led_cmd = &table[commands::LED_COLOR];
        
        assert!(is_crc8_position(led_cmd, 3));
        assert!(!is_crc8_position(led_cmd, 4));
    }

    #[test]
    fn test_counter_position_detection() {
        let table = get_command_table();
        let led_cmd = &table[commands::LED_COLOR];
        
        assert!(is_counter_position(led_cmd, 6));
        assert!(is_counter_position(led_cmd, 7));
        assert!(!is_counter_position(led_cmd, 8));
    }

    #[test]
    fn test_crc16_position_detection() {
        let table = get_command_table();
        let led_cmd = &table[commands::LED_COLOR];
        
        let positions = find_crc16_positions(led_cmd);
        assert!(positions.is_some());
        let (pos1, pos2) = positions.unwrap();
        assert_eq!(pos1, led_cmd.len() - 2);
        assert_eq!(pos2, led_cmd.len() - 1);
    }

    #[test]
    fn test_command_map_creation() {
        let map = create_command_map();
        assert!(map.contains_key("gimbal"));
        assert!(map.contains_key("twist"));
        assert!(map.contains_key("led_color"));
        assert_eq!(map["gimbal"], commands::GIMBAL);
    }

    #[test]
    fn test_boot_command_range() {
        assert_eq!(BOOT_COMMAND_START, 26);
        assert_eq!(BOOT_COMMAND_END, 34);
        assert_eq!(BOOT_COMMAND_END - BOOT_COMMAND_START + 1, 9); // 9 boot commands
    }
}
